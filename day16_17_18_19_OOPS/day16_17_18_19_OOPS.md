#  Introduction to Object-Oriented Programming (OOP)
- Imagine you're a chef in a kitchen. 
- In this kitchen, you have different types of utensils and ingredients. 
- Each type of utensil (like a frying pan or a spatula) has specific uses and ways to be handled, and each ingredient (like an onion or tomato) has its characteristics and ways it can be used. 
- Object-Oriented Programming (OOP) is somewhat like this kitchen.

- In OOP, everything is seen as an "object" – similar to how each utensil and ingredient in the kitchen is a distinct item with its specific features and uses.

## Key OOP Principles
1. **Encapsulation:** Understand how to bundle the data and the methods that operate on the data within one unit.
2. **Abstraction:** Learn to hide complex implementation details and show only the necessary features of an object.
3. **Inheritance:** Understand how a class can inherit attributes and methods from another class.
4. **Polymorphism:** Learn how to use a unified interface to operate on objects of different classes.

Let's continue with our kitchen analogy to understand the four key principles of Object-Oriented Programming (OOP): Encapsulation, Abstraction, Inheritance, and Polymorphism.

### Encapsulation
- Think of encapsulation as using a multi-compartment lunchbox to carry your meal. 
- Each compartment represents a section of the class where you store related items (data and methods). 
- For example, one compartment might hold a sandwich (data), and the lid (methods) might have instructions on how to eat it without making a mess. 
- Encapsulation allows you to:
  - **Bundle Data and Methods:** Just like a lunchbox holds both your food and the utensils to eat it, in encapsulation, data and the methods to manipulate the data are bundled together.
  - **Restrict Access:** You don't want everything in your lunchbox to be accessible to everyone. Similarly, encapsulation restricts direct access to some of the object's components, which can prevent accidental or unauthorized interactions.
### Abstraction
- Abstraction in OOP is like using a modern kitchen appliance, like a microwave. 
- You don't need to know all the complex engineering and physics behind how it works. 
- You only need to know the interface – the buttons and settings to use it. 
- Abstraction in OOP allows you to:
  - **Hide Complex Details:** Just like you don't need to know the microwave's inner workings, abstraction lets you hide the complex implementation details of a class from the user.
  - **Show Only the Necessary:** The microwave only shows what you need to know (buttons and settings). Similarly, abstraction lets you expose only the necessary methods and properties of an object, making the interface simpler and easier to use.
### Inheritance
- Imagine you have a basic recipe for a salad, and you want to make a variation of it, like a Greek salad. 
- Instead of writing a new recipe from scratch, you take the basic salad recipe and add some ingredients or steps to it. 
- This is inheritance – creating a new class (Greek salad) based on an existing class (basic salad) while retaining its features and adding new ones.
- Inheritance allows you to:
  - **Inherit Attributes and Methods:** A child class inherits all the attributes (ingredients) and methods (cooking steps) from the parent class but can also have its own unique attributes and methods.
  - **Avoid Code Duplication:** Just like you don't rewrite the entire salad recipe every time, inheritance lets you reuse code from parent classes, reducing redundancy and making the codebase cleaner and easier to maintain.
### Polymorphism
- This is like having different types of knives for cutting. 
- Each knife (object) can be used for cutting (method), but the way it cuts (behavior) can be different. 
- A serrated knife saws through bread, and a chef's knife chops vegetables. 
- They perform the same function (cutting), but the way they do it is different, depending on the object.
- Polymorphism allows you to:
  - **Use a Unified Interface:** Just like the action 'cut' can be applied to any knife, polymorphism lets you use a single interface (method name) to operate on objects of different classes.
  - **Implement Methods Differently:** Each knife cuts differently. Similarly, different classes can have their own implementation of the same interface or method. This is useful when different objects need to perform the same action in different ways.
By understanding and implementing these four pillars of OOP – Encapsulation, Abstraction, Inheritance, and Polymorphism – you can create a well-structured, efficient, and scalable codebase, much like running an efficient, versatile, and organized kitchen!

## Advantages of OOP
### 1. Code Reusability:
- Just like once you create a recipe, you can use it to make that dish as many times as you want, in OOP, once a class is written, it can be used to create multiple objects. 
- This avoids repetition and makes code easier to maintain.

### 2. Scalability:
- Imagine your kitchen can easily add new appliances or ingredients. 
- Similarly, OOP makes it easy to add new features and elements to your software. 
- You can create new classes or extend existing ones without drastically altering the existing code.

### 3. Manageability:
- A well-organized kitchen allows you to work more efficiently, knowing exactly where each utensil and ingredient is. 
- OOP allows you to organize your code into classes and objects, making it easier to manage, especially in large software projects where managing code can get complicated.

In summary, OOP is like running a kitchen, where: 
- utensils and ingredients are objects, 
- recipes are classes, and 
- the principles of OOP help in making the kitchen (software) more efficient, easier to manage, and scalable.

## OOPS and Python:
- Let's continue with the kitchen analogy to explain `classes` and `objects` in Python, along with some core concepts like the `__init__` method, instance variables, and methods.

## Defining Classes
- Think of a class as a recipe. 
- It's a blueprint for how to make something. 
- In this case, let's say we're making a recipe for a cake. 
- The recipe outlines what ingredients you need and the steps to make it, but it's not the cake itself.

```python
class Cake:
    def __init__(self, flavor):
        self.flavor = flavor

    def describe(self):
        print(f"This is a {self.flavor} cake.")
```
In this code:
- `class Cake`: starts the definition of our class (recipe).
- The `__init__` method is called automatically every time the class is being used to create a new object. This method sets up the object.
- `self.flavor = flavor` initializes the flavor of the cake. `self` represents the instance (specific cake) of the class (recipe), and `flavor` is an attribute.

## Creating Objects
- If the class is like a recipe, then an object is like the actual cake you bake using that recipe. 
- It's a real, tangible thing you can see and eat.

```python
my_cake = Cake("chocolate")
```
In this code:
`my_cake` is an instance (object) of the `Cake` class. You've made a chocolate cake!

## The `__init__` Method
- The `__init__` method is like the part of the recipe that tells you what ingredients to prepare before you start following the steps of the recipe. 
- It sets up your cake (object) with everything it needs to be a cake.

In the Cake class example:
- `__init__(self, flavor)` is preparing your cake by setting its flavor.

## Instance Variables and Methods
- Instance variables are like the specific ingredients for your cake. 
- If your recipe (class) says you need flour, each cake (object) you make might use a different amount of flour. 
- The flour for each cake is like an instance variable.

- Instance methods are like the steps in your recipe. 
- They tell you what you can do with your cake. 
- Maybe your recipe has a step to frost the cake. That's like an instance method.

In the Cake class example:
- `self.flavor = flavor` is an instance variable. Each cake can have a different flavor.
- `describe(self)` is an instance method. It allows the cake to describe itself.

When you put all these together in Python:

```python
class Cake:
    def __init__(self, flavor):
        self.flavor = flavor  # Instance variable

    def describe(self):  # Instance method
        print(f"This is a {self.flavor} cake.")

# Creating a Cake object
my_cake = Cake("chocolate")

# Using an instance method
my_cake.describe()  # Output: This is a chocolate cake.
```

- So, when you're using classes and objects in Python, think of it as writing and following a recipe in a kitchen.
- You have your recipe (class), your ingredients (instance variables), and your cooking steps (instance methods).
- And just like in cooking, you can create many different cakes (objects) from the same recipe (class), each with its own specific flavors and decorations (attributes and methods).

## Class Variables and Class Methods
- In object-oriented programming, especially in Python, classes act as blueprints for creating objects. 
- Classes can contain two main types of components: **variables** and **methods**. 
- Among these, there are distinctions based on whether they belong to the class itself or to instances of the class. 
- This brings us to class variables and class methods.

### Introduction to Class Variables
- Class variables are variables that are shared across all instances of a class. 
- They hold the same value for every instance of the class, making them ideal for storing properties that are common to all objects of the class. 
- If the value of a class variable is changed, the change is reflected across all instances.

### Introduction to Class Methods
- Class methods are methods that are bound to the class rather than its instances. 
- They can access and modify class state (i.e., class variables) that applies across all instances of the class. 
- Class methods are not concerned with individual instance variables. 
- Instead, they operate at the class level, affecting all instances of the class.

Let's consider the Cake class:
```python
class Cake:
    shape = "round"  # Class variable: Shared among all cakes

    def __init__(self, flavor):
        self.flavor = flavor  # Instance variable: Unique to each cake

    @classmethod
    def set_shape(cls, new_shape):
        cls.shape = new_shape  # Class method: Updates the shape for all cakes
```
In this class:
- **shape** is a `class variable`, meaning every Cake instance will initially have a shape of "round".
- **flavor** is an `instance variable`, meaning each Cake instance can have a different flavor.
- **set_shape** is a `class method` used to change the shape class variable, affecting the shape of all cakes, not just an individual cake.

### Explanation of `@classmethod`, `cls`, and Alternative Names
- `@classmethod` is a decorator in Python, indicating the following method is a class method.
- `cls` is a conventional parameter name in class methods, referring to the class itself. 
- While cls is not a keyword and you could technically use another name, it's a strong convention in Python to use `cls` for class methods, just like self is used for instance methods to refer to the instance.

### What Happens If We Don't Use @classmethod
- If you don't use the `@classmethod` decorator, the method will not be treated as a class method. 
- Instead, it will be considered an instance method and will expect self as the first parameter, referring to the instance of the class, not the class itself. 
- This means it won't be able to modify class variables in the way class methods can unless accessed through the class name explicitly.

### Expanding on the Cake Class Example
**Using set_shape with Object and Class References**
  - **Object Reference:** 
    - Even though `set_shape` is a class method (affecting the class variable for all instances), you can still call it on an instance of the class. 
    - For example: `chocolate_cake.set_shape("square")`
    - This will change the shape for all instances of `Cake`, not just for `chocolate_cake`. 
    - It's the same as calling `Cake.set_shape("square")`.

  - **Class Reference:** 
    - The typical way to use a class method is on the class itself, not on an instance of the class. 
    - For example: `Cake.set_shape("square")`
    - This makes it clear that the method is intended to operate on the class level, affecting all instances of the class.

### Objects Created Before and After Modifying Class Variables
- **Before Modification:** 
    - Objects created before the modification of a class variable retain access to the class variable. 
    - However, if the class variable is modified, these objects will see the new value, as class variables are shared across all instances.
```python
chocolate_cake = Cake("chocolate")  # shape is initially "round"
Cake.set_shape("square")  # shape changed to "square"
print(chocolate_cake.shape)  # This will print "square"
```
- **After Modification:** 
  - Objects created after the modification of a class variable will inherently access the modified class variable.
```python
Cake.set_shape("square")  # shape changed to "square"
vanilla_cake = Cake("vanilla")  # shape is "square" for this new object
```

## Static Methods
- Static methods, much like class methods, are a way to encapsulate functionality in a class without requiring a reference to a particular instance or the class itself. 
- They are marked with the `@staticmethod` decorator, indicating that they do not automatically receive an instance (`self`) or class (`cls`) reference as their first argument. 

### Introduction to Static Methods
- Static methods are functions defined within a class that don't access or modify the class state (class variables) or instance state (instance variables). 
- They are **utility functions that perform a task in isolation**.

- **Definition:** Static methods are defined using the `@staticmethod` decorator.
- **No self or cls:** Unlike instance methods or class methods, static methods do not receive an implicit first argument, either self or cls.
- **Utility Functions:** They are often used to implement functionality that logically belongs to the class but does not need to access the class or instance-specific data.


- Let's say we want to add a functionality to the Cake class that can suggest a serving size based on the cake's size, 
  but this calculation does not depend on the specific cake instance's properties nor the class's properties. 
- This is a perfect scenario for a static method.

```python
class Cake:
    shape = "round"  # Class variable: Shared among all cakes

    def __init__(self, flavor):
        self.flavor = flavor  # Instance variable: Unique to each cake

    @classmethod
    def set_shape(cls, new_shape):
        cls.shape = new_shape  # Class method: Updates the shape for all cakes

    @staticmethod
    def serving_size(cake_size):
        if cake_size <= 6:
            return "Small - Serves 2-4"
        elif cake_size <= 10:
            return "Medium - Serves 5-8"
        else:
            return "Large - Serves 9+"
```
In this class:

- `serving_size` is a **static method**, meaning it can be called on the class itself, not on a specific instance, and it doesn't modify the class or instance state.
- `cake_size` is just a regular parameter you pass to the method. It doesn't have any special behavior like `self` or `cls`.

### Usage of Static Methods
- You can call a static method using the class name, similar to class methods:
```python
print(Cake.serving_size(7))  # Output: "Medium - Serves 5-8"
```

### Characteristics of Static Methods
- **Namespace Organization:** Static methods keep methods logically associated with a class within the class's namespace.
- **Memory Efficiency:** They don't require an instance to be created to be called, which can be more memory-efficient.
- **Limited Access:** They cannot modify or access the properties of the class or instances of the class.

### Comparison with Class Methods and Instance Methods
**Class Methods:**
- Can access and modify class state.
- Receive the class as the implicit first argument (cls).

**Instance Methods:**
- Can access and modify instance state and class state.
- Receive the instance as the implicit first argument (self).

**Static Methods:**
- Do not access or modify instance or class state.
- Do not receive an implicit first argument.

Static methods are best used when you need a utility function that doesn't access any properties of a class but still makes sense to be included within the class's scope, as it's closely related to the class's purpose. 
This keeps the class self-contained and easier to understand and maintain.

## Private Members
- Private members in object-oriented programming (OOP) are attributes or methods of a class that are not accessible or visible to the outside of the class. 
- They're meant to be strictly used internally within the class. 
- This encapsulation is a core concept of OOP, aimed at creating a clear interface and preventing external entities from accessing the internal workings of a class directly. 
- Let's delve into this concept in Python, noting that Python's approach to privacy is based on a naming convention.

### Private Instance Variables:
- In Python, private instance variables are created by prefixing the variable name with two underscore characters (__).
- However, it's important to note that this doesn't enforce strict privacy but is more of a convention to indicate that the variable is meant to be private. 
- Here's an example:
```python
class Cake:
    def __init__(self, flavor, secret_sauce):
        self.flavor = flavor  # Public variable
        self.__secret_sauce = secret_sauce  # Private variable

    def get_secret_sauce(self):
        return self.__secret_sauce  # Accessing the private variable within the class

cake = Cake("Chocolate", 'abc')
print(cake.flavor)  # This will work, as flavor is public
print(cake.__secret_sauce)  # This will raise an error, as secret sauce is private
```
In the Cake class:
- `flavor` is a **public variable**, accessible from outside the class.
- `__secret_sauce` is a **private variable**, not intended to be accessed or modified directly from outside the class.

### Private Methods:
- Similarly, private methods are defined by prefixing the method name with two underscores. 
- They are meant to be called only within the class and not meant to be accessible from instances of the class or subclasses.

```python
class Cake:
    def __init__(self, ingredients):
        self.ingredients = ingredients
        self.__mix_ingredients()

    def __mix_ingredients(self):
        print("Mixing ingredients: ", self.ingredients)

cake = Cake(["flour", "sugar", "eggs"])
cake.__mix_ingredients()  # This will raise an error, as it's a private method
```
- Here, `__mix_ingredients` is a private method and is used internally by the `__init__` method.

### Name Mangling:
- In Python, private members are subject to **name mangling**. 
- The interpreter changes the name of the private attribute in a way that makes it harder to access unintentionally. 
- The new name is constructed by adding _ClassName before the attribute name.
- However, it's still possible to access private variables using name mangling:
```python
print(cake.__secret_sauce)  # This will raise an error, as secret sauce is private
print(cake._Cake__secret_sauce)  # This will work, but it's highly discouraged as it breaks the convention of private members.
```

## Inheritance
- Inheritance is a fundamental concept in object-oriented programming (OOP), allowing one class to inherit attributes and methods from another. 
- In Python, inheritance is used to create a new class that is a modified version of an existing class. 
- This promotes code reuse and establishes a hierarchical relationship between classes.

### Basic Concept of Inheritance
- **Base Class (Parent Class):** The class whose properties and methods are inherited.
- **Derived Class (Child Class):** The class that inherits properties and methods from the base class.

### Advantages of Inheritance
- **Code Reuse:** Common functionality can be written in the base class and specialized in the derived class.
- **Easy Maintenance:** Changes in the base class automatically propagate to derived classes, assuming they don't override base class methods.
- **Polymorphism:** A derived class can be treated as an instance of the base class, often useful in polymorphic behavior.

### Implementing Inheritance in Python
```python
# Base class
class Cake:
    def __init__(self, flavor):
        self.flavor = flavor

    def bake(self):
        print(f"Baking a {self.flavor} cake!")

# Derived class
class WeddingCake(Cake):
    def __init__(self, flavor, tiers):
        super().__init__(flavor)  # Call the __init__ of the base class
        self.tiers = tiers

    def bake(self):
        print(f"Baking a {self.tiers}-tier {self.flavor} wedding cake!")
```
In this example:
- `WeddingCake` inherits from `Cake`.
- `WeddingCake` calls the `__init__` method of `Cake` using `super().__init__(flavor)` to ensure the flavor attribute is set.
- `WeddingCake` has its own attribute `tiers`.
- `WeddingCake` overrides the `bake` method to provide a specialized message for a wedding cake.

### Types of Inheritance
1. **Single Inheritance:** A derived class inherits from one base class.
2. **Multiple Inheritance:** A derived class inherits from multiple base classes.
3. **Multilevel Inheritance:** A class inherits from a derived class, making it a base class for a new class.
4. **Hierarchical Inheritance:** Multiple classes inherit from a single base class.
5. **Hybrid Inheritance:** A combination of multiple and multilevel inheritance.

### Method Resolution Order (MRO)
- In cases of multiple inheritance, Python uses the **Method Resolution Order (MRO)** to determine the order in which base classes are searched when looking for a method. 
- This is important to understand when you have complex inheritance hierarchies and need to know how Python will find the correct method to use.

### super() Function
- `super()` is used to call methods from the base class:
- In single inheritance, it's straightforward: super() refers to the base class.
- In multiple inheritance, super() follows the MRO to determine the next class to look for methods.

### Single Inheritance
- A derived class inherits from one base class.
```python
class Cake:
    def __init__(self, flavor):
        self.flavor = flavor

class WeddingCake(Cake):
    def __init__(self, flavor, tiers):
        super().__init__(flavor)
        self.tiers = tiers

# Usage
cake = WeddingCake("Vanilla", 3)
print(cake.flavor)  # Output: Vanilla
```

### Multiple Inheritance
A derived class inherits from multiple base classes.

```python
class Cake:
    def __init__(self, flavor):
        self.flavor = flavor

class Frosting:
    def __init__(self, frosting_type):
        self.frosting_type = frosting_type

class FrostedCake(Cake, Frosting):
    def __init__(self, flavor, frosting_type):
        Cake.__init__(self, flavor)
        Frosting.__init__(self, frosting_type)

# Usage
frosted_cake = FrostedCake("Chocolate", "Buttercream")
print(frosted_cake.flavor, frosted_cake.frosting_type)  # Output: Chocolate Buttercream
```

### Multilevel Inheritance
- A class inherits from a derived class, making it a base class for a new class.
```python
class Cake:
    def __init__(self, flavor):
        self.flavor = flavor

class WeddingCake(Cake):
    def __init__(self, flavor, tiers):
        super().__init__(flavor)
        self.tiers = tiers

class DecoratedWeddingCake(WeddingCake):
    def __init__(self, flavor, tiers, decorations):
        super().__init__(flavor, tiers)
        self.decorations = decorations

# Usage
decorated_cake = DecoratedWeddingCake("Vanilla", 3, "Flowers")
print(decorated_cake.flavor, decorated_cake.tiers, decorated_cake.decorations)  # Output: Vanilla 3 Flowers
```

### Hierarchical Inheritance
- Multiple classes inherit from a single base class.
```python
class Cake:
    def __init__(self, flavor):
        self.flavor = flavor

class WeddingCake(Cake):
    def __init__(self, flavor, tiers):
        super().__init__(flavor)
        self.tiers = tiers

class BirthdayCake(Cake):
    def __init__(self, flavor, candles):
        super().__init__(flavor)
        self.candles = candles

# Usage
wedding_cake = WeddingCake("Vanilla", 3)
birthday_cake = BirthdayCake("Chocolate", 24)
print(wedding_cake.flavor, wedding_cake.tiers)  # Output: Vanilla 3
print(birthday_cake.flavor, birthday_cake.candles)  # Output: Chocolate 24
```

### Hybrid Inheritance
- A combination of multiple and multilevel inheritance.
```python
class Cake:
    def __init__(self, flavor):
        self.flavor = flavor

class Frosting:
    def __init__(self, frosting_type):
        self.frosting_type = frosting_type

class FrostedCake(Cake, Frosting):
    def __init__(self, flavor, frosting_type):
        Cake.__init__(self, flavor)
        Frosting.__init__(self, frosting_type)

class WeddingFrostedCake(FrostedCake):
    def __init__(self, flavor, frosting_type, tiers):
        super().__init__(flavor, frosting_type)
        self.tiers = tiers

# Usage
wedding_frosted_cake = WeddingFrostedCake("Red Velvet", "Cream Cheese", 4)
print(wedding_frosted_cake.flavor, wedding_frosted_cake.frosting_type, wedding_frosted_cake.tiers)  # Output: Red Velvet Cream Cheese 4
```

### Method Overriding
- A derived class can provide a specific implementation of a method that is already defined in its base class. 
- This is known as method overriding. 
- In the `WeddingCake` example, the `bake` method is overridden to provide a custom implementation for WeddingCake.

## Abstract Classes and Methods
- Abstract classes and methods are fundamental concepts in object-oriented programming, enabling you to create a **blueprint for other classes**. 
- They're particularly useful when you want to define a template for a group of subclasses and ensure they all follow the same structure or interface.

###  Abstract Classes:
- An abstract class is a class that cannot be instantiated on its own. 
- Instead, it is designed to be subclassed by other classes. 
- Abstract classes are used to define a common interface for a set of subclasses.

### Characteristics of Abstract Classes:
- **Cannot be Instantiated:** You cannot create an instance of an abstract class directly.
- **Subclassing Required:** They are meant to be base classes, which need to be extended by other subclasses.
- **Common Interface:** Abstract classes provide a way to define methods that must be created within any child classes built from the abstract class.

### Abstract Methods:
- An abstract method is a method that is declared in the abstract class but it does not have an implementation. 
- Subclasses are expected to implement this method.

### Characteristics of Abstract Methods:
- **Declaration Only:** An abstract method is declared but contains no implementation. Subclasses are expected to provide an implementation of this method.
- **Enforces Structure in Subclasses:** If a subclass inherits from an abstract class, it must implement all abstract methods of the parent class.

### Implementing Abstract Classes and Methods in Python:
- Python provides the `abc` module (**Abstract Base Classes**) to use abstract classes and methods. 
- Here's how you can create an abstract class and abstract methods:
```python
from abc import ABC, abstractmethod

class Cake(ABC):
    
    def __init__(self, flavor):
        self.flavor = flavor

    @abstractmethod
    def serve(self):
        pass

class Cupcake(Cake):
    def serve(self):
        return f"Serving a {self.flavor} cupcake."

class Pancake(Cake):
    def serve(self):
        return f"Serving a stack of {self.flavor} pancakes."
```
In this example:
- `Cake` is an **abstract class** because it contains the abstract method `serve`.
- `serve` is an abstract method. It's declared by using the `@abstractmethod` decorator, and it defines the method signature without an implementation.
- `Cupcake` and `Pancake` are **concrete classes** that inherit from Cake and provide their own implementation of the serve method.

### Usage of Abstract Classes and Methods:
- **Ensuring Consistency:** Abstract classes ensure that all subclasses built from them implement the same set of methods.
- **Design and Planning:** They are excellent for designing and planning your code, especially in large projects where you need a clear and consistent structure.
- **Preventing Instantiation:** Making a class abstract prevents it from being instantiated, which can be useful when you have a class that is designed only as a base class.

## Decorators in Relation to OOP in Python
- Decorators are a powerful feature in Python that allow you to modify or enhance the behavior of functions or methods. 
- In the context of OOP, decorators can be incredibly useful for adding functionality to methods and classes or for modifying their behavior without altering the original code structure.
  - Function Decorators
  - Method Decorators
  - Class Decorators

### Function Decorators
- Function decorators are applied to standalone functions. 
- They are a type of higher-order function that take a function as an argument and return a new function, enhancing or modifying the original function's behavior.
```python
def add_garnish(func):
    def wrapper():
        print("Adding garnish.")
        func()
        print("Garnish added.")
    return wrapper

@add_garnish
def cook_dish():
    print("Preparing Cake.")

cook_dish()
# Output:
# Adding garnish.
# Preparing Cake.
# Garnish added.
```
In this example, `add_garnish` enhances `cook_dish` without modifying its internal code.

### Method Decorators
- Method decorators work similarly to function decorators but are used within classes. 
- They can modify the behavior of **class methods**. 
- Common built-in method decorators in Python are `@classmethod`, `@staticmethod`, and `@property`.

### The `@property` Decorator in Detail
- `@property` is a built-in decorator that allows you to **define methods in a class that can be accessed like attributes**. 
- This has several advantages, including improving the readability of your code and allowing you to implement value checking or computation inside the getter and setter methods.

**Basic Structure**
Here's a basic example to illustrate how @property works:

```python
class MyClass:
    def __init__(self, value):
        self._attribute = value

    @property
    def attribute(self):
        # Getter method
        print("Getting attribute")
        return self._attribute

    @attribute.setter
    def attribute(self, value):
        # Setter method
        print("Setting attribute")
        self._attribute = value

    @attribute.deleter
    def attribute(self):
        # Deleter method
        print("Deleting attribute")
        del self._attribute


# Create an instance of MyClass
my_obj = MyClass("Initial Value")

# Access the 'attribute' property (triggers the getter)
print(my_obj.attribute)  # Output: Getting attribute \n Initial Value

# Set the 'attribute' property to a new value (triggers the setter)
my_obj.attribute = "New Value"  # Output: Setting attribute

# Access the 'attribute' property again to see the new value
print(my_obj.attribute)  # Output: Getting attribute \n New Value

# Delete the 'attribute' property (triggers the deleter)
del my_obj.attribute  # Output: Deleting attribute

# Try to access the 'attribute' property after deletion (this will raise an AttributeError)
try:
    print(my_obj.attribute)
except AttributeError as e:
    print(e)  # Output: 'MyClass' object has no attribute '_attribute'
```
- In this example, attribute acts like a normal attribute, but 
- when you assign a value to it, the `setter` method is called, and 
- when you retrieve its value, the `getter` method is called.


```python
class Cake:
    def __init__(self, flavor):
        self._flavor = flavor  # Initialize with an underscore to indicate it's for internal use.

    @property
    def flavor(self):
        """Get the flavor of the cake."""
        print("Getting the flavor")
        return self._flavor

    @flavor.setter
    def flavor(self, value):
        """Set the flavor of the cake. The value must be a non-empty string."""
        if not isinstance(value, str) or not value.strip():
            raise ValueError("Flavor must be a non-empty string")
        print("Setting the flavor")
        self._flavor = value

# Usage
cake = Cake("Chocolate")
print(cake.flavor)  # Output: Getting the flavor \n Chocolate

cake.flavor = "Vanilla"  # Output: Setting the flavor
print(cake.flavor)  # Output: Getting the flavor \n Vanilla

try:
    cake.flavor = ""  # This will raise an exception
except ValueError as e:
    print(e)  # Output: Flavor must be a non-empty string
```

**Components of @property**
- **Getter Method:** 
  - This method is used to get the value of the attribute. 
  - It's defined using the `@property` decorator. 
  - When you access the attribute, this method is automatically called to retrieve its value.

- **Setter Method:** 
  - This method is used to set the value of the attribute. 
  - It's defined with the `@<attribute_name>.setter` decorator. 
  - This allows you to include logic for validation or processing of the value before it's actually set.

- **Deleter Method:** 
  - This method is used to delete the attribute. 
  - It's defined with the `@<attribute_name>.deleter` decorator. This allows you to include cleanup logic or other necessary steps when the attribute is deleted.

- **Benefits of Using @property**
  - **Encapsulation:** 
    - You can keep the internal representation private and expose only the getter and setter methods to access or modify it.
  - **Validation and Checking:** 
    - In the setter method, you can include checks and validations. 
    - For example, if you want an attribute to always be positive, you can check the value before setting it.
  - **Computed Properties:** 
    - You can compute the value of a property every time it's accessed instead of storing it. 
    - This is useful if the property value is derived from other properties and you want it to be up-to-date.
  - **Readability:** 
    - Accessing methods as if they were attributes makes the client code more readable and intuitive.

### Class Decorators
- Class decorators are applied to classes and can modify or enhance the entire class behavior.
```python
def singleton(cls):
    instances = {}
    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return wrapper

@singleton
class Cake:
    def __init__(self, flavor):
        self._flavor = flavor

cake1 = Cake("chocolate")
cake2 = Cake("vanilla")

print(cake1 is cake2)  # Output: True
print(cake1._flavor)   # Output: chocolate
print(cake2._flavor)   # Output: chocolate
```
Explanation
- **Initialization:** When the Cake class is first instantiated (`cake1 = Cake("chocolate")`), the singleton decorator checks if an instance of Cake already exists.
- **Instance Creation:** As there's no instance yet, it creates one and stores it in the instances dictionary.
- **Subsequent Instantiation:** When a new Cake instance is attempted to be created (`cake2 = Cake("vanilla")`), the decorator provides the already created instance.
- **Single Instance Enforcement:** Both cake1 and cake2 reference the same instance. Even though we attempted to instantiate cake2 with "vanilla", the singleton decorator ensures that only the first instance ("chocolate") is used.

Real World Example
```python
def singleton(cls):
    instances = {}
    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return wrapper

@singleton
class Database:
    pass
```

## Polymorphism
- Polymorphism, meaning "many forms," is a concept where a name (like a method name) can have multiple forms or behaviors. 
- It allows objects of different classes to be treated as objects of a common superclass.
  - Method Overriding 
  - Operator Overloading
  - Duck Typing

### Method Overriding 
- The same method or property name can be used in different classes, and each class can provide its own implementation of the method or property.
- This is particularly powerful in combination with inheritance, where a child class can override or extend the behavior of a parent class.

```python
# Base Class
class Cake:
    def __init__(self, flavor):
        self._flavor = flavor

    def serve(self):
        return f"Serving a basic {self._flavor} cake."

# Subclass 1: Cupcake
class Cupcake(Cake):
    def serve(self):
        return f"Serving a {self._flavor} cupcake."

# Subclass 2: Pancake
class Pancake(Cake):
    def serve(self):
        return f"Serving {self._flavor} pancakes."

# We can now create instances of Cake, Cupcake, and Pancake and 
# call the serve method on each, observing how the same method name behaves differently based on the object's class.

basic_cake = Cake("chocolate")
print(basic_cake.serve())  # Output: "Serving a basic chocolate cake."

choco_cupcake = Cupcake("chocolate")
print(choco_cupcake.serve())  # Output: "Serving a chocolate cupcake."

banana_pancake = Pancake("banana")
print(banana_pancake.serve())  # Output: "Serving banana pancakes."
```
- In the above code, even though each object is calling a method named serve, the actual method that gets called depends on the type of the object, demonstrating polymorphism.

### Operator Overloading
- Operator overloading allows the same operator to have different meanings according to the context. 
- Here, let's overload the `+` operator for the Cake class to combine flavors.
```python
class Cake:
    def __init__(self, flavor):
        self._flavor = flavor

    def __add__(self, other):
        # Overloading the + operator to combine cake flavors
        return Cake(f"{self._flavor}-{other._flavor}")
    
    def serve(self):
        return f"Serving a basic {self._flavor} cake."

chocolate_cake = Cake("chocolate")
vanilla_cake = Cake("vanilla")

combined_cake = chocolate_cake + vanilla_cake
print(combined_cake.serve())  # Output: "Serving a basic chocolate-vanilla cake."
```
- In this example, the `+` operator is overloaded to combine the flavors of two cakes, creating a **new Cake instance** with the combined flavor.

### Duck Typing
- Duck Typing is a concept related to **dynamic typing**, where the class or type of an object is less important than the methods it defines or the attributes it holds. 
- "If it looks like a duck and quacks like a duck, it's a duck."
```python
class Cake:
    def serve(self):
        return f"Serving a cake."

class Cookie:
    def serve(self):
        return "Serving a cookie."

def bake(cake):
    print(cake.serve())

chocolate_cake = Cake()
choco_chip_cookie = Cookie()

bake(chocolate_cake)  # Output: Serving a cake.
bake(choco_chip_cookie)  # Output: Serving a cookie.
```
In the above example, 
- the `bake` function expects an object that has a serve method. 
- It doesn't care about the class of the object. 
- Both `Cake` and `Cookie` have a serve method, so they can both be passed to the bake function. 
- This is an example of duck typing, where the type of the object is not checked, just the presence of a specific method or attribute.

## Encapsulation:
- Encapsulation is one of the fundamental concepts in object-oriented programming (OOP). 
- It describes the idea of bundling data (attributes) and methods (functions that operate on the data) into a single unit or class. 
- Additionally, it restricts direct access to some of an object's components, which is a way of preventing accidental interference and misuse of the internal methods and data.

### Importance of Hiding Data:
- **Security:** Hiding the internal state of the object protects its integrity by preventing outside interference and misuse.
- **Simplicity:** A well-encapsulated class exposes only what is necessary to the user. This means the user can use the class without understanding the complex internal workings.
- **Flexibility and Maintainability:** The implementation of the class can be changed without affecting the parts of the program that use it.
### Implementing Encapsulation in Python
- Python doesn't have the private keyword, unlike some other object-oriented languages, but encapsulation can be achieved using conventions and features of the language.
- **Using Single Underscore Prefix (_)**
  - A single underscore prefix in Python is a convention to indicate to the programmer that a variable or method should be treated as "protected". 
  - It tells others "please don't use this unless you are a subclass". 
  - However, it is still accessible, which means it's more about trust and convention than enforcement.

- **Using Double Underscore Prefix (__)**
- Double underscore prefix causes **name mangling**. 
- Python interpreter changes the name of the variable in a way that makes it harder to create subclasses that accidentally override the private methods and attributes of their superclasses. 
- It's not truly private, but it's a way to avoid accidental access.

Example with the Cake Class to illustrate encapsulation:
```python
class Cake:
    def __init__(self, flavor):
        self._flavor = flavor  # Protected attribute

    @property
    def flavor(self):
        """Get the flavor of the cake."""
        return self._flavor

    @flavor.setter
    def flavor(self, value):
        """Set the flavor of the cake. Only allows string values."""
        if isinstance(value, str):
            self._flavor = value
        else:
            raise ValueError("Flavor must be a string.")

    def _bake(self):
        """Protected method to bake the cake."""
        print(f"Baking the {self._flavor} cake.")

    def serve(self):
        """Public method to serve the cake."""
        self._bake()  # Calling the protected method
        return f"Serving the {self._flavor} cake."
```
In this example:
- The `_flavor` attribute is intended to be a protected attribute. 
- It's not meant to be accessed directly from outside the class; instead, it's accessed and modified through the flavor property.
- The `_bake` method is a protected method, signifying that it's intended for internal use within the class or subclasses, not for external use.
- The `serve` method is a public method that internally uses the protected _bake method.
- Users of the `Cake` class are meant to call serve without needing to know about the internal _bake method.

---

## Composition(has-a relationship) vs Inheritance(is-a relationship):
- **Inheritance** 
  - It is a mechanism that allows a new class to inherit attributes and methods from an existing class. 
  - The class that inherits is called the subclass (or derived class), and the class it inherits from is called the superclass (or base class).

```python
# Base class
class Cake:
    def __init__(self, flavor):
        self.flavor = flavor

    def serve(self):
        return f"Serving a {self.flavor} cake."

# Subclass 1
class Cupcake(Cake):
    def serve(self):
        return f"Serving a {self.flavor} cupcake."

# Subclass 2
class Pancake(Cake):
    def serve(self):
        return f"Serving a stack of {self.flavor} pancakes."
``` 
- In this example, Cupcake and Pancake are subclasses of Cake. 
- They inherit the flavor attribute and override the serve method to provide their specific serving style.

- **Composition**
  - Composition is a design principle where a class is composed of one or more objects from other classes. 
  - This is often described as a **"has-a"** relationship. 
  - Composition allows you to model complex types by combining objects of other types, meaning that a class can contain instances of other classes as members.

Suppose we have a class Bakery that has a list of Cake objects.

```python
class Cake:
    def __init__(self, flavor):
        self.flavor = flavor

    def serve(self):
        return f"Serving a {self.flavor} cake."

# Subclass 1
class Cupcake(Cake):
    def serve(self):
        return f"Serving a {self.flavor} cupcake."
    
class Bakery:
    def __init__(self):
        self.cakes = []

    def add_cake(self, cake):
        self.cakes.append(cake)

    def show_menu(self):
        for cake in self.cakes:
            print(cake.serve())

# Creating instances of Cake
chocolate_cake = Cake("Chocolate")
vanilla_cupcake = Cupcake("Vanilla")

# Creating a Bakery instance
local_bakery = Bakery()

# Adding cakes to the bakery
local_bakery.add_cake(chocolate_cake)
local_bakery.add_cake(vanilla_cupcake)

# Showing the bakery's menu
local_bakery.show_menu()
```
In this example, 
- the Bakery class doesn't inherit from the Cake class but instead has a list of Cake objects. 
- This is a classic example of composition. 
- The Bakery class is composed of Cake objects and can use their methods and attributes.

## Mixin Classes:
- Mixins are a type of class in object-oriented programming, particularly in Python, that are used to offer reusable functionalities for other classes. 
- Unlike traditional base classes, mixins don't define a new type but provide methods that can be used by other classes without requiring inheritance from a common ancestor, apart from object. 
- This design pattern allows behaviors to be added to classes in a modular and composable way.

### Characteristics of Mixins:
- **No Direct Instantiation:** Mixins are not meant to stand on their own. They are meant to be inherited by another class that seeks to use the functionality they provide.
- **Single Responsibility:** Each mixin is focused on a single, specific task or feature, adhering to the Single Responsibility Principle.
- **No Internal State:** Ideally, mixins don't maintain a state of their own. They provide methods that act upon the state of the classes they are mixed into.

### Benefits of Mixins:
- **Reusability:** Code can be reused across different classes.
- **Modularity:** Functions are packaged into separate, interchangeable modules.
- **Avoid Complexity of Multiple Inheritance:** Mixins can be used to simulate multiple inheritance in languages that don't support it natively, like Java.

Example Using Mixins with the Cake Class:
- Suppose we want to add different functionalities to the `Cake` class like `FrostingMixin` for adding frosting and `DecorationMixin` for adding decorations. 
- Instead of directly adding these methods to the Cake class or creating a complex inheritance structure, we can define mixins.

```python
class FrostingMixin:
    def add_frosting(self, frosting):
        print(f"Adding {frosting} frosting to the cake.")

class DecorationMixin:
    def add_decoration(self, decoration):
        print(f"Decorating the cake with {decoration}.")

class Cake:
    def __init__(self, flavor):
        self.flavor = flavor

    def serve(self):
        return f"Serving a {self.flavor} cake."

# Extending the Cake class with mixins
class FrostedCake(Cake, FrostingMixin, DecorationMixin):
    pass

# Creating an instance of FrostedCake
birthday_cake = FrostedCake("chocolate")
print(birthday_cake.serve())  # Serving a chocolate cake.
birthday_cake.add_frosting("chocolate")  # Adding chocolate frosting to the cake.
birthday_cake.add_decoration("candles")  # Decorating the cake with candles.
```
In this example, 
- `FrostingMixin` and `DecorationMixin` are mixins added to the `FrostedCake` class. 
- The `FrostedCake` class can now use the methods defined in both mixins, enhancing its functionality. 
- The mixins can also be used by other classes that might need these specific functionalities, promoting code reuse and modularity.

---

## Exception Handling
- Exception handling in Python is a mechanism that allows you to catch and respond to errors that occur during the execution of a program. 
- Python uses `try-except` blocks to handle exceptions, ensuring that the program can continue to run or gracefully terminate even when an error is encountered.
- Basic Structure of Exception Handling:
```python
try:
    # Code block where exceptions might occur
except SomeException:
    # Code to handle the exception
```

Cake Class with Exception Handling
```python
class Cake:
    def __init__(self, flavor):
        self._set_flavor(flavor)

    def _set_flavor(self, flavor):
        try:
            if not isinstance(flavor, str):
                raise TypeError("Flavor must be a string.")
            if flavor == "":
                raise ValueError("Flavor cannot be empty.")
            self._flavor = flavor
        except (TypeError, ValueError) as e:
            print(f"Error: {e}")
            self._flavor = None

    def serve(self):
        if self._flavor is not None:
            return f"Serving a {self._flavor} cake."
        else:
            return "Cake has no flavor."

# Using the Cake class
try:
    chocolate_cake = Cake("chocolate")
    print(chocolate_cake.serve())  # Output: "Serving a chocolate cake."

    no_flavor_cake = Cake("")  # Will raise ValueError and be caught
    print(no_flavor_cake.serve())  # Output: "Cake has no flavor."
    
    number_flavor_cake = Cake(123)  # Will raise TypeError and be caught
    print(number_flavor_cake.serve())  # Output: "Cake has no flavor."
except Exception as e:
    print(f"An error occurred: {e}")
```

In this example, 
- the `_set_flavor` method includes a try-except block to handle cases where the flavor might not be a string or is an empty string. 
- If an exception occurs, it prints an error message and sets the _flavor attribute to None.

---

## Descriptors
- Descriptors are a powerful feature in Python that allow you to create managed attributes. 
- In object-oriented programming, descriptors are objects that implement a protocol of special methods (`__get__`, `__set__`, and `__delete__`). 
- These methods are triggered upon attribute access, making descriptors an essential part of Python's machinery for building classes.

### Components of Descriptors
`__get__(self, obj, type=None):` 
- Called to get the attribute value. 
- The obj is the instance being manipulated, and the type is the type of the object.

`__set__(self, obj, value):` 
- Called to set the attribute value. 
- The obj is the instance, and the value is the value being assigned to the attribute.

`__delete__(self, obj):` Called to delete the attribute.

A descriptor is:
- **Data Descriptor:** If it implements both __get__ and __set__.
- **Non-data Descriptor:** If it only implements __get__.

Let's use descriptors to manage the flavor attribute of the Cake class, ensuring the flavor name is always a string and not empty.

**Flavor Descriptor**
```python
class FlavorDescriptor:
    def __init__(self):
        self._flavor = None

    def __get__(self, obj, objtype=None):
        return self._flavor

    def __set__(self, obj, value):
        if not isinstance(value, str):
            raise TypeError("Flavor must be a string.")
        if value == "":
            raise ValueError("Flavor cannot be empty.")
        self._flavor = value

class Cake:
    flavor = FlavorDescriptor()

    def __init__(self, flavor):
        self.flavor = flavor  # Will trigger __set__ in FlavorDescriptor

    def serve(self):
        return f"Serving a {self.flavor} cake."

chocolate_cake = Cake("chocolate")
print(chocolate_cake.serve())  # Output: "Serving a chocolate cake."

try:
    chocolate_cake.flavor = ""  # Will raise ValueError
except ValueError as e:
    print(e)  # Output: "Flavor cannot be empty."

try:
    chocolate_cake.flavor = 123  # Will raise TypeError
except TypeError as e:
    print(e)  # Output: "Flavor must be a string."
```
In this example, 
- `FlavorDescriptor` manages the `flavor` attribute. 
- When `flavor` is assigned in the `Cake` class, the `__set__` method of `FlavorDescriptor` is called, enforcing the rules that the flavor must be a non-empty string.


# Assignment
Practical Example - Normalizers

```python
# normalization

from abc import ABC, abstractmethod
import datetime

class Normalizer(ABC):
    @abstractmethod
    def normalize(self, data):
        pass

class DateNormalizer(Normalizer):
    def normalize(self, data):
        print("date normalizer")
        year, month, date = data.split("-")
        date_obj = datetime.date(int(year), int(month), int(date))
        print(date_obj.strftime("%d %B, %y"))

class USDateNormalizer(DateNormalizer):
    def normalize(self, data):
        print("US Date normalizer")
        year, month, date = data.split("-")
        print(f"{month}/{date}/{year}")

class IndiaDateNormalizer(DateNormalizer):
    def normalize(self, data):
        print("India Date normalizer")
        year, month, date = data.split("-")
        print(f"{date}/{month}/{year}")


date_normalizer = DateNormalizer()
us_date_normalizer = USDateNormalizer()
india_date_normalizer = IndiaDateNormalizer()

general_date = date_normalizer.normalize("2024-01-31")  # 31st Jan, 2024
us_date_normalizer.normalize("2024-01-31")  # 01/31/2024
india_date_normalizer.normalize("2024-01-31")  # 31/01/2024
```